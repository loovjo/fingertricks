import sys
import time
import numpy as np

rot_x = np.array([
    [1, 0, 0],
    [0, 0, -1],
    [0, 1, 0],
])
rot_xi = np.linalg.inv(rot_x)
rot_x2 = np.dot(rot_x, rot_x)

rot_y = np.array([
    [0, 0, 1],
    [0, 1, 0],
    [-1, 0, 0],
])
rot_yi = np.linalg.inv(rot_y)
rot_y2 = np.dot(rot_y, rot_y)

rot_z = np.array([
    [0, 1, 0],
    [-1, 0, 0],
    [0, 0, 1],
])
rot_zi = np.linalg.inv(rot_z)
rot_z2 = np.dot(rot_z, rot_z)

base_rotations = [
    ([], np.eye(3)),
    (["x"], rot_x),
    (["xi"], rot_xi),
    (["y"], rot_y),
    (["yi"], rot_yi),
    (["z"], rot_z),
    (["zi"], rot_zi),
    (["x2"], rot_x2),
    (["y2"], rot_y2),
    (["z2"], rot_z2),
]

r = np.array([1, 0, 0])
side_dirs = {
    "r": r,
    "l": -r,
    "u": np.dot(rot_zi, r),
    "d": np.dot(rot_z, r),
    "f": np.dot(rot_y, r),
    "b": np.dot(rot_yi, r),
}

rotations = []
visited_mats = set()
visiting = [([], np.eye(3))]

while len(visiting) > 0:
    best_idx = 0
    for i, (name_parts, _) in enumerate(visiting):
        if len(name_parts) < len(visiting[best_idx][0]):
            best_idx = i

    name_parts, mat = visiting.pop(best_idx)
    if mat.tobytes() in visited_mats:
        continue

    visited_mats.add(mat.tobytes())
    rotations.append((name_parts, mat))

    for (rname_parts, rmat) in base_rotations[1:]:
        fin_mat = np.dot(rmat, mat)

        fin_name_parts = name_parts + rname_parts
        visiting.append((fin_name_parts, fin_mat))

print("Moves:", [name_parts for name_parts, _ in rotations], file=sys.stderr)
print("Count = ", len(rotations), file=sys.stderr)

print("Checking consistency...", file=sys.stderr)
for n1, m1 in rotations:
    for n2, m2 in rotations:
        matching = [n for n, m in rotations if np.all(np.dot(m2, m1) == m)]

        if len(matching) != 1:
            print("No impl for", n1, "*", n2, file=sys.stderr)
            exit()

    for n2, v2 in side_dirs.items():
        matching = [n for n, v in side_dirs.items() if np.all(np.dot(m1, v2) == v)]

        if len(matching) != 1:
            print("No impl for", n1, "*", n2, file=sys.stderr)
            exit()

print("Consistent!", file=sys.stderr)


def fmt_name_from_parts(parts):
    if len(parts) == 0:
        return "Ident"
    return "_".join(part[0].upper() + part[1:] for part in parts)


names_enum = ",\n    ".join(
    fmt_name_from_parts(name_parts) for name_parts, _ in rotations)

side_names = ",\n    ".join(k.upper() for k in side_dirs.keys())

side_names_qual = ", ".join("Side::" + k.upper() for k in side_dirs.keys())

print(f"""\
// Auto-generated by gen_rotation.py
use std::convert::Into;

#[allow(unused)]
pub const SIDES: &[Side] = &[{side_names_qual}];

#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Side {{
    {side_names},
}}

#[allow(unused)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum FullCubeRotation {{
    {names_enum},
}}

impl FullCubeRotation {{
    fn combine(self, other: FullCubeRotation) -> FullCubeRotation {{
        match (self, other) {{""")

for me_name_parts, me_mat in rotations:
    for other_name_parts, other_mat in rotations:
        matching = [
            n for n, m in rotations if np.all(np.dot(other_mat, me_mat) == m)
        ]
        res_name_parts = matching[0]

        me_n = fmt_name_from_parts(me_name_parts)
        other_n = fmt_name_from_parts(other_name_parts)
        res_n = fmt_name_from_parts(res_name_parts)

        print(f"""\
            (FullCubeRotation::{me_n}, FullCubeRotation::{other_n}) => FullCubeRotation::{res_n},"""
              )

base_names_enum = ",\n    ".join(
    fmt_name_from_parts(name_parts) for name_parts, _ in base_rotations)

print(f"""\
        }}
    }}

    fn decompose(self) -> Vec<BaseCubeRotation> {{
        match self {{""")
for me_name_parts, _ in rotations:
    me_name = fmt_name_from_parts(me_name_parts)
    parts = ", ".join("BaseCubeRotation::" + fmt_name_from_parts([part]) for part in me_name_parts)

    print(f"""\
            FullCubeRotation::{me_name} => vec![{parts}],""")

print(f"""\
        }}
    }}
    fn apply_to_side(self, side: Side) -> Side {{
        match (self, side) {{""")

for me_name_parts, rot_mat in rotations:
    for side, vec in side_dirs.items():
        matching = [
            n for n, v in side_dirs.items() if np.all(np.dot(np.linalg.inv(rot_mat), vec) == v)
        ]

        me_n = fmt_name_from_parts(me_name_parts)
        side_name = fmt_name_from_parts([side])
        res_name = fmt_name_from_parts([matching[0]])

        print(f"""\
            (FullCubeRotation::{me_n}, Side::{side_name}) => Side::{res_name},"""
              )


print(f"""
        }}
    }}
}}

#[allow(unused)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum BaseCubeRotation {{
    {base_names_enum},
}}

impl Into<FullCubeRotation> for BaseCubeRotation {{
    fn into(self) -> FullCubeRotation {{
        match self {{""")

for me_name_parts, _ in base_rotations:
    me_name = fmt_name_from_parts(me_name_parts)
    print(f"""\
            BaseCubeRotation::{me_name} => FullCubeRotation::{me_name},""")

print(f"""\
        }}
    }}
}}
""")


print("Done!", file=sys.stderr)
